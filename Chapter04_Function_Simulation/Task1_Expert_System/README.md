# 动物识别专家系统

基于产生式规则的正向与反向推理实现（纯Python版本）

## 🌟 关键特性

- 🚀 **纯Python实现** - 无需PyKnow等外部框架
- 🧠 **双向推理** - 支持正向推理（数据驱动）和反向推理（目标驱动）
- ⚡ **智能优先级** - 三层架构（100/200/300），条件越多优先级越高
- 🔧 **冲突消解** - 综合考虑优先级和具体性的智能消解机制
- 📊 **完整记录** - 详细的推理过程、规则触发历史和事实演化
- 🎯 **高准确性** - 可识别7种动物，具体规则优先匹配

## 📋 目录

- [项目简介](#项目简介)
- [系统架构](#系统架构)
- [核心模块说明](#核心模块说明)
- [安装和运行](#安装和运行)
- [使用示例](#使用示例)
- [知识库内容](#知识库内容)
  - [规则层次与优先级设计](#规则层次与优先级设计)
- [核心特性](#核心特性)
- [技术实现对比](#技术实现对比)
- [扩展方向](#扩展方向)
- [项目优势](#项目优势)

## 项目简介

这是一个不使用PyKnow框架的纯Python实现的专家系统，演示了：
- 正向推理（数据驱动）
- 反向推理（目标驱动）
- 冲突消解机制
- 完整的推理过程记录

## 系统架构

```
动物识别专家系统/
├── facts.py              # 事实定义模块
├── rule.py               # 规则定义模块
├── knowledge_base.py     # 知识库模块（13条规则，三层优先级）
├── conflict_resolver.py  # 冲突消解器（优先级+具体性策略）
├── forward_engine.py     # 正向推理引擎（数据驱动）
├── backward_engine.py    # 反向推理引擎（目标驱动）
├── main.py               # 主程序（用户交互界面）
├── test_forward.py       # 正向推理测试
├── test_salience.py      # 优先级验证测试
├── README.md             # 项目说明文档
└── SALIENCE_DESIGN.md    # 优先级设计详解
```

### 数据流示意图

```
正向推理流程：
用户输入特征 → 事实库 → 规则匹配 → 冲突消解 → 触发规则 → 新事实 → 循环 → 识别结果

反向推理流程：
目标假设 → 查找支持规则 → 验证前提 → 询问用户/递归验证 → 确认/排除目标
```

## 核心模块说明

### 1. facts.py - 事实模型
定义系统中使用的各种事实类型：
- `HasFeature`: 特征事实（如"有毛发"）
- `IsClassification`: 分类事实（如"哺乳动物"）
- `IsAnimal`: 动物事实（如"豹"）

### 2. rule.py - 规则引擎
实现规则的定义和执行：
- 规则条件检查
- 规则动作执行
- 优先级管理

### 3. knowledge_base.py - 知识库
存储所有领域知识规则：
- 13条推理规则
- 3个优先级层次（100-199, 200-299, 300-399）
- 可识别7种动物
- 智能优先级分配：条件越多优先级越高

### 4. conflict_resolver.py - 冲突消解
实现冲突消解策略：
- 优先级策略（salience值）
- 专一性策略（条件数量）
- 冲突历史记录

### 5. forward_engine.py - 正向推理
数据驱动的推理引擎：
- 从已知事实出发
- 自底向上推导
- 自动匹配和触发规则

### 6. backward_engine.py - 反向推理
目标驱动的推理引擎：
- 从目标假设出发
- 自顶向下验证
- 交互式询问用户

## 安装和运行

### 环境要求
- Python 3.6+
- 无需安装第三方库

### 运行方法
```bash
python main.py
```

## 使用示例

### 正向推理示例

**场景：识别豹**

```bash
$ python main.py
选择功能: 1. 正向推理模式

输入特征: 有毛发,吃肉,黄褐色,暗斑点
```

**推理过程：**
```
【阶段1】添加初始事实:
  添加事实: 动物有特征 '有毛发'
  添加事实: 动物有特征 '吃肉'
  添加事实: 动物有特征 '黄褐色'
  添加事实: 动物有特征 '暗斑点'

【阶段2】开始推理循环:

--- 推理迭代 1 ---
  发现 1 条可应用的规则
  选择规则: rule_has_hair (优先级=100)
  规则描述: 如果有毛发，那么是哺乳动物
  → 推导出分类: 哺乳动物

--- 推理迭代 2 ---
  发现 1 条可应用的规则
  选择规则: rule_carnivore (优先级=200)
  规则描述: 如果是哺乳动物且吃肉，那么是食肉动物
  → 推导出分类: 食肉动物

--- 推理迭代 3 ---
  发现 1 条可应用的规则
  选择规则: rule_leopard (优先级=330)
  规则描述: 如果是食肉动物且黄褐色且有暗斑点，那么是豹
  → 识别出动物: 豹

✓ 识别结果: 该动物是 【豹】

推理统计:
  • 推理耗时: 0.0005 秒
  • 推理步骤数: 7
  • 触发规则数: 3
  • 最终事实数: 7
```

### 反向推理示例

**场景：通过提问识别动物**

```bash
$ python main.py
选择功能: 2. 反向推理模式

系统将通过提问的方式识别动物
按回车键开始...
```

**交互过程：**
```
尝试识别: 豹

验证目标: 食肉动物
验证目标: 哺乳动物

问题 1: 动物有 '有毛发' 这个特征吗？
  请回答 (y/n 或 是/否): y
  ✓ 用户确认: 动物有 '有毛发'

验证目标: 吃肉
问题 2: 动物有 '吃肉' 这个特征吗？
  请回答 (y/n 或 是/否): y
  ✓ 用户确认: 动物有 '吃肉'

验证目标: 黄褐色
问题 3: 动物有 '黄褐色' 这个特征吗？
  请回答 (y/n 或 是/否): y
  ✓ 用户确认: 动物有 '黄褐色'

验证目标: 暗斑点
问题 4: 动物有 '暗斑点' 这个特征吗？
  请回答 (y/n 或 是/否): y
  ✓ 用户确认: 动物有 '暗斑点'

✓ 识别结果: 该动物是 【豹】

推理统计:
  • 推理耗时: 12.3456 秒
  • 提问次数: 4
  • 验证的目标数: 7
  • 推理路径长度: 15
```

## 知识库内容

### 可识别的动物（7种）
1. 豹 - 食肉动物，黄褐色，暗斑点
2. 虎 - 食肉动物，黄褐色，黑色条纹
3. 长颈鹿 - 有蹄类，长腿，长脖子，黄褐色，暗斑点
4. 斑马 - 有蹄类，黑白条纹
5. 鸵鸟 - 鸟类，长腿，长脖子，不会飞
6. 企鹅 - 鸟类，不会飞，会游泳，黑白两色
7. 信天翁 - 鸟类，善飞

### 规则层次与优先级设计

本系统采用**三层分级优先级架构**，通过数量级分离和具体性原则实现智能推理。

#### 第1层：基础分类规则 (优先级 100-199)
从基础特征推导出动物大类

| 优先级 | 条件数 | 规则示例 |
|--------|--------|---------|
| 100 | 1 | 有毛发 → 哺乳动物 |
| 100 | 1 | 产奶 → 哺乳动物 |
| 100 | 1 | 有羽毛 → 鸟类 |
| 110 | 2 | 会飞 + 生蛋 → 鸟类 |

#### 第2层：中间分类规则 (优先级 200-299)
从大类推导出更具体的子类

| 优先级 | 条件数 | 规则示例 |
|--------|--------|---------|
| 200 | 2 | 哺乳动物 + 吃肉 → 食肉动物 |
| 200 | 2 | 哺乳动物 + 有蹄 → 有蹄类动物 |

#### 第3层：具体识别规则 (优先级 300-399)
从子类和特征推导出具体物种（**条件越多优先级越高**）

| 优先级 | 条件数 | 物种 | 规则示例 |
|--------|--------|------|---------|
| **350** | **5** | 长颈鹿 | 有蹄类 + 长腿 + 长脖子 + 黄褐色 + 暗斑点 |
| **340** | **4** | 鸵鸟 | 鸟类 + 长腿 + 长脖子 + 不会飞 |
| **340** | **4** | 企鹅 | 鸟类 + 不会飞 + 会游泳 + 黑白两色 |
| **330** | **3** | 豹 | 食肉动物 + 黄褐色 + 暗斑点 |
| **330** | **3** | 虎 | 食肉动物 + 黄褐色 + 黑色条纹 |
| **320** | **2** | 斑马 | 有蹄类 + 黑白条纹 |
| **320** | **2** | 信天翁 | 鸟类 + 善飞 |

#### 优先级设计原则

**1. 数量级分离**
```
第1层: 100-199  →  基础特征识别
第2层: 200-299  →  中间分类推导
第3层: 300-399  →  具体物种识别
```
- 不同层次使用不同数量级，一眼识别规则层次
- 每层预留100个优先级值，便于扩展

**2. 具体性优先**
```
条件数量 ↑  →  优先级 ↑  →  优先触发
```
- 条件越多的规则越具体，应该优先匹配
- 避免泛化规则掩盖具体规则
- 提高识别准确性

**3. 层次推进**
```
特征 (100) → 大类 (200) → 子类 → 物种 (300-399)
```
- 推理自然遵循从一般到具体的流程
- 每层输出成为下一层输入

> 💡 详细的优先级设计说明请参考 `SALIENCE_DESIGN.md`

## 核心特性

### 1. 模块化设计
- 清晰的模块划分
- 低耦合高内聚
- 易于扩展和维护

### 2. 推理过程记录
- 完整的推理步骤
- 规则触发历史
- 事实演化过程

### 3. 冲突消解
- 多策略支持
- 冲突历史分析
- 统计信息输出

### 4. 双向推理
- 正向推理：适合数据完整的场景
- 反向推理：适合交互式诊断

## 技术实现对比

### 与PyKnow框架的对比

| 特性 | PyKnow版本 | 纯Python版本 |
|------|-----------|-------------|
| 依赖 | 需要pyknow库 | 无外部依赖 |
| 学习曲线 | 需要学习框架API | 易于理解 |
| 灵活性 | 受框架限制 | 完全可控 |
| 性能 | 框架优化 | 手动优化 |
| 可扩展性 | 框架约束 | 自由扩展 |

### 实现细节

**规则匹配**
```python
def check_conditions(self, facts):
    for condition in self.conditions:
        if not self._check_single_condition(condition, facts):
            return False
    return True
```

**冲突消解**
```python
def resolve(self, conflicting_rules):
    sorted_rules = sorted(
        conflicting_rules,
        key=lambda r: (r.salience, len(r.conditions)),
        reverse=True
    )
    return sorted_rules[0]
```

**推理循环**
```python
while True:
    applicable_rules = self.find_applicable_rules()
    if not applicable_rules:
        break
    
    selected_rule = self.conflict_resolver.resolve(applicable_rules)
    new_facts = selected_rule.execute(self.facts)
    self.facts.extend(new_facts)
    self.fired_rules.add(selected_rule.name)
```

## 扩展方向

### 1. 添加新动物
在 `knowledge_base.py` 中添加新的识别规则，并按以下规则设置优先级：
```python
# 根据条件数量设置优先级
salience = 300 + (条件数 * 10)
# 例如：6条件规则 → 优先级360
```

### 2. 增加新特征
在规则条件中添加新的特征判断

### 3. 改进冲突消解
实现更复杂的消解策略（如元规则、动态优先级）

### 4. 调整优先级策略
参考 `SALIENCE_DESIGN.md` 优化规则优先级：
- 第1层规则：100-199（基础分类）
- 第2层规则：200-299（中间分类）
- 第3层规则：300-399（具体识别，条件越多优先级越高）

### 5. 性能优化
- 使用Rete算法优化规则匹配
- 添加规则索引加速查找
- 实现增量式事实更新

### 6. 用户界面
- 添加图形界面（GUI）
- 实现Web接口
- 可视化推理过程

## 项目优势

✅ **无框架依赖** - 纯Python实现，易于部署  
✅ **代码清晰** - 模块化设计，易于理解  
✅ **功能完整** - 正反向推理，冲突消解  
✅ **智能优先级** - 三层架构+具体性原则，推理准确  
✅ **可扩展** - 每层预留100优先级空间，易于添加规则  
✅ **教学友好** - 适合学习专家系统原理  
